# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `concurrent-ruby` gem.
# Please instead update this file by running `bin/tapioca gem concurrent-ruby`.

# typed: true

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Logger::Severity
  extend ::Concurrent::Concern::Logging
  extend ::Concurrent::Concern::Deprecation

  private

  def monotonic_time; end

  class << self
    def create_simple_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end
    def create_stdlib_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end
    def disable_at_exit_handlers!; end
    def executor(executor_identifier); end
    def global_fast_executor; end
    def global_immediate_executor; end
    def global_io_executor; end
    def global_logger; end
    def global_logger=(value); end
    def global_timer_set; end
    def monotonic_time; end
    def new_fast_executor(opts = T.unsafe(nil)); end
    def new_io_executor(opts = T.unsafe(nil)); end
    def physical_processor_count; end
    def processor_count; end
    def processor_counter; end
    def use_simple_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end
    def use_stdlib_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end
  end
end

class Concurrent::AbstractExecutorService < ::Concurrent::Synchronization::LockableObject
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Deprecation

  def initialize(opts = T.unsafe(nil), &block); end

  def auto_terminate=(value); end
  def auto_terminate?; end
  def fallback_policy; end
  def kill; end
  def name; end
  def running?; end
  def shutdown; end
  def shutdown?; end
  def shuttingdown?; end
  def to_s; end
  def wait_for_termination(timeout = T.unsafe(nil)); end

  private

  def handle_fallback(*args); end
  def ns_auto_terminate?; end
  def ns_execute(*args, &task); end
  def ns_kill_execution; end
  def ns_shutdown_execution; end
end

Concurrent::AbstractExecutorService::FALLBACK_POLICIES = T.let(T.unsafe(nil), Array)

module Concurrent::AtomicDirectUpdate
  def try_update; end
  def try_update!; end
  def update; end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

class Concurrent::AtomicReference < ::Concurrent::MutexAtomicReference
  def inspect; end
  def to_s; end
end

Concurrent::AtomicReferenceImplementation = Concurrent::MutexAtomicReference

class Concurrent::CachedThreadPool < ::Concurrent::ThreadPoolExecutor
  def initialize(opts = T.unsafe(nil)); end

  private

  def ns_initialize(opts); end
end

class Concurrent::CancelledOperationError < ::Concurrent::Error; end
module Concurrent::Collection; end

class Concurrent::Collection::CopyOnNotifyObserverSet < ::Concurrent::Synchronization::LockableObject
  def initialize; end

  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def notify_and_delete_observers(*args, &block); end
  def notify_observers(*args, &block); end

  protected

  def ns_initialize; end

  private

  def duplicate_and_clear_observers; end
  def duplicate_observers; end
  def notify_to(observers, *args); end
end

class Concurrent::Collection::CopyOnWriteObserverSet < ::Concurrent::Synchronization::LockableObject
  def initialize; end

  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def notify_and_delete_observers(*args, &block); end
  def notify_observers(*args, &block); end

  protected

  def ns_initialize; end

  private

  def clear_observers_and_return_old; end
  def notify_to(observers, *args); end
  def observers; end
  def observers=(new_set); end
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend < ::Concurrent::Collection::NonConcurrentMapBackend
  def initialize(options = T.unsafe(nil)); end

  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def get_and_set(key, value); end
  def merge_pair(key, value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
end

class Concurrent::Collection::NonConcurrentMapBackend
  def initialize(options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def each_pair; end
  def get_and_set(key, value); end
  def get_or_default(key, default_value); end
  def key?(key); end
  def merge_pair(key, value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
  def size; end

  private

  def _get(key); end
  def _set(key, value); end
  def dupped_backend; end
  def initialize_copy(other); end
  def pair?(key, expected_value); end
  def store_computed_value(key, new_value); end
end

class Concurrent::Collection::NonConcurrentPriorityQueue < ::Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end
  def deq; end
  def enq(item); end
  def has_priority?(item); end
  def shift; end
  def size; end
end

Concurrent::Collection::NonConcurrentPriorityQueueImplementation = Concurrent::Collection::RubyNonConcurrentPriorityQueue

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def initialize(opts = T.unsafe(nil)); end

  def <<(item); end
  def clear; end
  def delete(item); end
  def deq; end
  def empty?; end
  def enq(item); end
  def has_priority?(item); end
  def include?(item); end
  def length; end
  def peek; end
  def pop; end
  def push(item); end
  def shift; end
  def size; end

  private

  def ordered?(x, y); end
  def sink(k); end
  def swap(x, y); end
  def swim(k); end

  class << self
    def from_list(list, opts = T.unsafe(nil)); end
  end
end

module Concurrent::Concern; end

module Concurrent::Concern::Deprecation
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  extend ::Concurrent::Concern::Logging
  extend ::Concurrent::Concern::Deprecation

  def deprecated(message, strip = T.unsafe(nil)); end
  def deprecated_method(old_name, new_name); end
end

module Concurrent::Concern::Dereferenceable
  def deref; end
  def value; end

  protected

  def apply_deref_options(value); end
  def ns_set_deref_options(opts); end
  def set_deref_options(opts = T.unsafe(nil)); end
  def value=(value); end
end

module Concurrent::Concern::Logging
  include ::Logger::Severity

  def log(level, progname, message = T.unsafe(nil), &block); end
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable

  def complete?; end
  def exception(*args); end
  def fulfilled?; end
  def incomplete?; end
  def no_error!(timeout = T.unsafe(nil)); end
  def pending?; end
  def realized?; end
  def reason; end
  def rejected?; end
  def state; end
  def unscheduled?; end
  def value(timeout = T.unsafe(nil)); end
  def value!(timeout = T.unsafe(nil)); end
  def wait(timeout = T.unsafe(nil)); end
  def wait!(timeout = T.unsafe(nil)); end

  protected

  def compare_and_set_state(next_state, *expected_current); end
  def event; end
  def get_arguments_from(opts = T.unsafe(nil)); end
  def if_state(*expected_states); end
  def init_obligation; end
  def ns_check_state?(expected); end
  def ns_set_state(value); end
  def set_state(success, value, reason); end
  def state=(value); end
end

module Concurrent::Concern::Observable
  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def with_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end

  protected

  def observers; end
  def observers=(_arg0); end
end

class Concurrent::ConcurrentUpdateError < ::ThreadError; end
Concurrent::ConcurrentUpdateError::CONC_UP_ERR_BACKTRACE = T.let(T.unsafe(nil), Array)
class Concurrent::ConfigurationError < ::Concurrent::Error; end

class Concurrent::Delay < ::Concurrent::Synchronization::LockableObject
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Obligation

  def initialize(opts = T.unsafe(nil), &block); end

  def reconfigure(&block); end
  def value(timeout = T.unsafe(nil)); end
  def value!(timeout = T.unsafe(nil)); end
  def wait(timeout = T.unsafe(nil)); end

  protected

  def ns_initialize(opts, &block); end

  private

  def execute_task_once; end
end

class Concurrent::Error < ::StandardError; end

class Concurrent::Event < ::Concurrent::Synchronization::LockableObject
  def initialize; end

  def reset; end
  def set; end
  def set?; end
  def try?; end
  def wait(timeout = T.unsafe(nil)); end

  protected

  def ns_initialize; end
  def ns_set; end
end

module Concurrent::ExecutorService
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging

  def <<(task); end
  def can_overflow?; end
  def post(*args, &task); end
  def serialized?; end
end

Concurrent::GLOBAL_FAST_EXECUTOR = T.let(T.unsafe(nil), Concurrent::Delay)
Concurrent::GLOBAL_IMMEDIATE_EXECUTOR = T.let(T.unsafe(nil), Concurrent::ImmediateExecutor)
Concurrent::GLOBAL_IO_EXECUTOR = T.let(T.unsafe(nil), Concurrent::Delay)
Concurrent::GLOBAL_LOGGER = T.let(T.unsafe(nil), Concurrent::AtomicReference)
Concurrent::GLOBAL_MONOTONIC_CLOCK = T.let(T.unsafe(nil), T.untyped)
Concurrent::GLOBAL_TIMER_SET = T.let(T.unsafe(nil), Concurrent::Delay)

class Concurrent::IVar < ::Concurrent::Synchronization::LockableObject
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Observable

  def initialize(value = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end
  def fail(reason = T.unsafe(nil)); end
  def set(value = T.unsafe(nil)); end
  def try_set(value = T.unsafe(nil), &block); end

  protected

  def check_for_block_or_value!(block_given, value); end
  def complete(success, value, reason); end
  def complete_without_notification(success, value, reason); end
  def notify_observers(value, reason); end
  def ns_complete_without_notification(success, value, reason); end
  def ns_initialize(value, opts); end
  def safe_execute(task, args = T.unsafe(nil)); end
end

class Concurrent::IllegalOperationError < ::Concurrent::Error; end

class Concurrent::ImmediateExecutor < ::Concurrent::AbstractExecutorService
  include ::Concurrent::SerialExecutorService

  def initialize; end

  def <<(task); end
  def kill; end
  def post(*args, &task); end
  def running?; end
  def shutdown; end
  def shutdown?; end
  def shuttingdown?; end
  def wait_for_termination(timeout = T.unsafe(nil)); end
end

class Concurrent::ImmutabilityError < ::Concurrent::Error; end
class Concurrent::InitializationError < ::Concurrent::Error; end
class Concurrent::LifecycleError < ::Concurrent::Error; end

class Concurrent::Map < ::Concurrent::Collection::MriMapBackend
  def initialize(options = T.unsafe(nil), &block); end

  def [](key); end
  def []=(key, value); end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fetch(key, default_value = T.unsafe(nil)); end
  def fetch_or_store(key, default_value = T.unsafe(nil)); end
  def get(key); end
  def inspect; end
  def key(value); end
  def keys; end
  def marshal_dump; end
  def marshal_load(hash); end
  def put(key, value); end
  def put_if_absent(key, value); end
  def value?(value); end
  def values; end

  private

  def initialize_copy(other); end
  def populate_from(hash); end
  def raise_fetch_no_key; end
  def validate_options_hash!(options); end
end

class Concurrent::MaxRestartFrequencyError < ::Concurrent::Error; end

class Concurrent::MultipleAssignmentError < ::Concurrent::Error
  def initialize(message = T.unsafe(nil), inspection_data = T.unsafe(nil)); end

  def inspect; end
  def inspection_data; end
end

class Concurrent::MultipleErrors < ::Concurrent::Error
  def initialize(errors, message = T.unsafe(nil)); end

  def errors; end
end

class Concurrent::MutexAtomicReference < ::Concurrent::Synchronization::LockableObject
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper

  def initialize(value = T.unsafe(nil)); end

  def _compare_and_set(old_value, new_value); end
  def compare_and_swap(old_value, new_value); end
  def get; end
  def get_and_set(new_value); end
  def set(new_value); end
  def swap(new_value); end
  def value; end
  def value=(new_value); end

  protected

  def ns_initialize(value); end
end

Concurrent::NULL = T.let(T.unsafe(nil), Object)
Concurrent::NULL_LOGGER = T.let(T.unsafe(nil), Proc)

module Concurrent::Options
  class << self
    def executor(executor_identifier); end
    def executor_from_options(opts = T.unsafe(nil)); end
  end
end

class Concurrent::Promise < ::Concurrent::IVar
  def initialize(opts = T.unsafe(nil), &block); end

  def catch(&block); end
  def execute; end
  def fail(reason = T.unsafe(nil)); end
  def flat_map(&block); end
  def on_error(&block); end
  def on_success(&block); end
  def rescue(&block); end
  def set(value = T.unsafe(nil), &block); end
  def then(*args, &block); end
  def zip(*others); end

  protected

  def complete(success, value, reason); end
  def notify_child(child); end
  def ns_initialize(value, opts); end
  def on_fulfill(result); end
  def on_reject(reason); end
  def realize(task); end
  def root?; end
  def set_pending; end
  def set_state!(success, value, reason); end
  def synchronized_set_state!(success, value, reason); end

  class << self
    def aggregate(method, *promises); end
    def all?(*promises); end
    def any?(*promises); end
    def execute(opts = T.unsafe(nil), &block); end
    def fulfill(value, opts = T.unsafe(nil)); end
    def reject(reason, opts = T.unsafe(nil)); end
    def zip(*promises); end
  end
end

class Concurrent::PromiseExecutionError < ::StandardError; end
class Concurrent::RejectedExecutionError < ::Concurrent::Error; end
class Concurrent::ResourceLimitError < ::Concurrent::Error; end

class Concurrent::RubyExecutorService < ::Concurrent::AbstractExecutorService
  def initialize(*args, &block); end

  def kill; end
  def post(*args, &task); end
  def shutdown; end
  def wait_for_termination(timeout = T.unsafe(nil)); end

  private

  def ns_running?; end
  def ns_shutdown?; end
  def ns_shutdown_execution; end
  def ns_shuttingdown?; end
  def stop_event; end
  def stopped_event; end
end

class Concurrent::RubySingleThreadExecutor < ::Concurrent::RubyThreadPoolExecutor
  def initialize(opts = T.unsafe(nil)); end
end

class Concurrent::RubyThreadPoolExecutor < ::Concurrent::RubyExecutorService
  def initialize(opts = T.unsafe(nil)); end

  def can_overflow?; end
  def completed_task_count; end
  def idletime; end
  def largest_length; end
  def length; end
  def max_length; end
  def max_queue; end
  def min_length; end
  def queue_length; end
  def ready_worker(worker); end
  def remaining_capacity; end
  def remove_busy_worker(worker); end
  def scheduled_task_count; end
  def synchronous; end
  def worker_died(worker); end
  def worker_not_old_enough(worker); end
  def worker_task_completed; end

  private

  def ns_add_busy_worker; end
  def ns_assign_worker(*args, &task); end
  def ns_enqueue(*args, &task); end
  def ns_execute(*args, &task); end
  def ns_initialize(opts); end
  def ns_kill_execution; end
  def ns_limited_queue?; end
  def ns_prune_pool; end
  def ns_ready_worker(worker, success = T.unsafe(nil)); end
  def ns_remove_busy_worker(worker); end
  def ns_reset_if_forked; end
  def ns_shutdown_execution; end
  def ns_worker_died(worker); end
  def ns_worker_not_old_enough(worker); end
end

Concurrent::RubyThreadPoolExecutor::DEFAULT_MAX_POOL_SIZE = T.let(T.unsafe(nil), Integer)
Concurrent::RubyThreadPoolExecutor::DEFAULT_MAX_QUEUE_SIZE = T.let(T.unsafe(nil), Integer)
Concurrent::RubyThreadPoolExecutor::DEFAULT_MIN_POOL_SIZE = T.let(T.unsafe(nil), Integer)
Concurrent::RubyThreadPoolExecutor::DEFAULT_THREAD_IDLETIMEOUT = T.let(T.unsafe(nil), Integer)

class Concurrent::RubyThreadPoolExecutor::Worker
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging

  def initialize(pool, id); end

  def <<(message); end
  def kill; end
  def stop; end

  private

  def create_worker(queue, pool, idletime); end
  def run_task(pool, task, args); end
end

class Concurrent::SafeTaskExecutor < ::Concurrent::Synchronization::LockableObject
  def initialize(task, opts = T.unsafe(nil)); end

  def execute(*args); end
end

class Concurrent::ScheduledTask < ::Concurrent::IVar
  include ::Comparable

  def initialize(delay, opts = T.unsafe(nil), &task); end

  def <=>(other); end
  def cancel; end
  def cancelled?; end
  def execute; end
  def executor; end
  def initial_delay; end
  def process_task; end
  def processing?; end
  def reschedule(delay); end
  def reset; end
  def schedule_time; end

  protected

  def ns_reschedule(delay); end
  def ns_schedule(delay); end

  class << self
    def execute(delay, opts = T.unsafe(nil), &task); end
  end
end

module Concurrent::SerialExecutorService
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  include ::Concurrent::ExecutorService

  def serialized?; end
end

class Concurrent::SingleThreadExecutor < ::Concurrent::RubySingleThreadExecutor; end
Concurrent::SingleThreadExecutorImplementation = Concurrent::RubySingleThreadExecutor
module Concurrent::Synchronization; end

class Concurrent::Synchronization::AbstractLockableObject < ::Concurrent::Synchronization::Object
  protected

  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = T.unsafe(nil)); end
  def ns_wait_until(timeout = T.unsafe(nil), &condition); end
  def synchronize; end
end

class Concurrent::Synchronization::AbstractObject
  def initialize; end

  def full_memory_barrier; end

  class << self
    def attr_volatile(*names); end
  end
end

class Concurrent::Synchronization::Condition < ::Concurrent::Synchronization::LockableObject
  def initialize(lock); end

  def broadcast; end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = T.unsafe(nil)); end
  def ns_wait_until(timeout = T.unsafe(nil), &condition); end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until(timeout = T.unsafe(nil), &condition); end

  class << self
    def private_new(*args, &block); end
  end
end

module Concurrent::Synchronization::ConditionSignalling
  protected

  def ns_broadcast; end
  def ns_signal; end
end

class Concurrent::Synchronization::Lock < ::Concurrent::Synchronization::LockableObject
  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until(timeout = T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::LockableObject < ::Concurrent::Synchronization::MutexLockableObject
  def new_condition; end
end

Concurrent::Synchronization::LockableObjectImplementation = Concurrent::Synchronization::MutexLockableObject

class Concurrent::Synchronization::MonitorLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling

  def initialize(*defaults); end

  protected

  def ns_wait(timeout = T.unsafe(nil)); end
  def synchronize; end

  private

  def initialize_copy(other); end

  class << self
    def new(*args, &block); end
  end
end

module Concurrent::Synchronization::MriAttrVolatile
  mixes_in_class_methods ::Concurrent::Synchronization::MriAttrVolatile::ClassMethods

  def full_memory_barrier; end

  class << self
    def included(base); end
  end
end

module Concurrent::Synchronization::MriAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

class Concurrent::Synchronization::MriObject < ::Concurrent::Synchronization::AbstractObject
  include ::Concurrent::Synchronization::MriAttrVolatile
  extend ::Concurrent::Synchronization::MriAttrVolatile::ClassMethods

  def initialize; end
end

class Concurrent::Synchronization::MutexLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling

  def initialize(*defaults); end

  protected

  def ns_wait(timeout = T.unsafe(nil)); end
  def synchronize; end

  private

  def initialize_copy(other); end

  class << self
    def new(*args, &block); end
  end
end

class Concurrent::Synchronization::Object < ::Concurrent::Synchronization::MriObject
  def initialize; end

  private

  def __initialize_atomic_fields__; end

  class << self
    def atomic_attribute?(name); end
    def atomic_attributes(inherited = T.unsafe(nil)); end
    def attr_atomic(*names); end
    def ensure_safe_initialization_when_final_fields_are_present; end
    def safe_initialization!; end
    def safe_initialization?; end

    private

    def define_initialize_atomic_fields; end
  end
end

Concurrent::Synchronization::ObjectImplementation = Concurrent::Synchronization::MriObject

module Concurrent::Synchronization::RbxAttrVolatile
  mixes_in_class_methods ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods

  def full_memory_barrier; end

  class << self
    def included(base); end
  end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

class Concurrent::Synchronization::RbxLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  def initialize(*defaults); end

  protected

  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = T.unsafe(nil)); end
  def synchronize(&block); end

  private

  def initialize_copy(other); end

  class << self
    def new(*args, &block); end
  end
end

class Concurrent::Synchronization::RbxObject < ::Concurrent::Synchronization::AbstractObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods

  def initialize; end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  mixes_in_class_methods ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods

  def full_memory_barrier; end

  class << self
    def included(base); end
  end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

class Concurrent::Synchronization::TruffleRubyObject < ::Concurrent::Synchronization::AbstractObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods

  def initialize; end
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile
class Concurrent::ThreadPoolExecutor < ::Concurrent::RubyThreadPoolExecutor; end
Concurrent::ThreadPoolExecutorImplementation = Concurrent::RubyThreadPoolExecutor
class Concurrent::TimeoutError < ::Concurrent::Error; end

class Concurrent::TimerSet < ::Concurrent::RubyExecutorService
  def initialize(opts = T.unsafe(nil)); end

  def kill; end
  def post(delay, *args, &task); end

  private

  def ns_initialize(opts); end
  def ns_post_task(task); end
  def ns_reset_if_forked; end
  def ns_shutdown_execution; end
  def post_task(task); end
  def process_tasks; end
  def remove_task(task); end
end

module Concurrent::Utility; end

module Concurrent::Utility::EngineDetector
  def on_cruby?; end
  def on_jruby?; end
  def on_jruby_9000?; end
  def on_linux?; end
  def on_osx?; end
  def on_rbx?; end
  def on_truffleruby?; end
  def on_windows?; end
  def ruby_engine; end
  def ruby_version(version = T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?; end
  def c_extensions_loaded?; end
  def java_extensions_loaded?; end
  def load_native_extensions; end

  private

  def load_error_path(error); end
  def set_c_extensions_loaded; end
  def set_java_extensions_loaded; end
  def try_load_c_extension(path); end
end

class Concurrent::Utility::ProcessorCounter
  def initialize; end

  def physical_processor_count; end
  def processor_count; end

  private

  def compute_physical_processor_count; end
  def compute_processor_count; end
end
